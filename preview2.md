## 训练环境配置、编码技巧和Code Style
1. 熟练应用快捷键加快编码

2. 主干代码写在上面，小的代码、子代码写在下面

3. 使用==(自顶向下)==的编码方式

### 自顶向下
+ 先写框架，不写具体函数内容

+ 写具体函数的内容

## 时间复杂度和空间复杂度分析
### 时间复杂度
1. + O(1)
   + O(log n)
   + O(n)
   + O(n^2)
   + O(n^3)
   + O(2^n)
   + O(n!)
   只看最高复杂度的运算，不关心常数系数
2. 直接看代码，看根据n的不同，代码会运行多少次
3. 简单的递归求Fibonacci是O(k^n)
```
int fib(int n){
        if (n<2) return n;
        return fib(n-1)+fib(n-2);
}
```
4. O(n!)>O(2^n)>O(n^2)>O(n log n)>O(n)>O(log n)>O(1)
5. 同一个任务不同复杂度的影响
> 计算1+2+...+n
> 1. O(n)
>   ```
>   y=0
>   for i=1 to n:
>       y+=1
>   ```
> 2. 求和公式: sum = n(n+1)/2 O(1)-->无论n等于几程序都只执行一次
>   ```
>   y = n*(n+1)/2
>   ```
6. 递归情况下的复杂度计算
+ 画出递归状态的状态树
7. 主定理
+ 一维数组进行二分查找 O(log n)
+ 二叉树的遍历 O(n)
+ 在排好序的矩阵中进行二分查找 O(n)
+ 归并排序 O(nlogn)
思考题

Q:二叉树的遍历-前序、中序、后序的时间复杂度

A:
  1. 根据主定理，时间复杂度为O(n)
  2. 无论前序、中序还是后序遍历，所有的节点都会被访问且只会被访问一次，所以他的时间复杂度的线性于节点数目，因而为O(n)

Q: 图的遍历的时间复杂度

A: O(n),n为图中节点数目

Q: 搜索算法 DFS、BFS的时间复杂度是多少

A: O(n),其中n指的是搜索空间里的节点总数，原理同二叉树、图的遍历

### 空间复杂度
1. 数组的长度
如果代码中有数组，空间复杂度基本上就是数组的程度
2. 递归的深度(特殊说明)

1. 如果是一维数据，传入的参数为n，则空间复杂度为n
   同理如果是二维数组，则为n^2
2. 如果既有递归又有数组，则取大值